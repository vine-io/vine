// Code generated by proto-gen-gogo. DO NOT EDIT.
// source: github.com/vine-io/vine/lib/api/handler/openapi/proto/openapi.proto

package openapi

import (
	context "context"
	ebinary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

var _ = ebinary.BigEndian

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

type GetOpenAPIDocRequest struct {
}

func (m *GetOpenAPIDocRequest) Reset()         { *m = GetOpenAPIDocRequest{} }
func (m *GetOpenAPIDocRequest) String() string { return proto.CompactTextString(m) }
func (*GetOpenAPIDocRequest) ProtoMessage()    {}
func (*GetOpenAPIDocRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{0}
}
func (m *GetOpenAPIDocRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOpenAPIDocRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOpenAPIDocRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOpenAPIDocRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOpenAPIDocRequest.Merge(m, src)
}
func (m *GetOpenAPIDocRequest) XXX_Size() int {
	return m.XSize()
}
func (m *GetOpenAPIDocRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOpenAPIDocRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetOpenAPIDocRequest proto.InternalMessageInfo

type GetOpenAPIDocResponse struct {
	Apis []*OpenAPI `protobuf:"bytes,1,rep,name=apis,proto3" json:"apis,omitempty"`
}

func (m *GetOpenAPIDocResponse) Reset()         { *m = GetOpenAPIDocResponse{} }
func (m *GetOpenAPIDocResponse) String() string { return proto.CompactTextString(m) }
func (*GetOpenAPIDocResponse) ProtoMessage()    {}
func (*GetOpenAPIDocResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{1}
}
func (m *GetOpenAPIDocResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOpenAPIDocResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOpenAPIDocResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOpenAPIDocResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOpenAPIDocResponse.Merge(m, src)
}
func (m *GetOpenAPIDocResponse) XXX_Size() int {
	return m.XSize()
}
func (m *GetOpenAPIDocResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOpenAPIDocResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetOpenAPIDocResponse proto.InternalMessageInfo

type OpenAPI struct {
	Openapi      string                  `protobuf:"bytes,1,opt,name=openapi,proto3" json:"openapi,omitempty"`
	Info         *OpenAPIInfo            `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
	ExternalDocs *OpenAPIExternalDocs    `protobuf:"bytes,3,opt,name=externalDocs,proto3" json:"externalDocs,omitempty"`
	Servers      []*OpenAPIServer        `protobuf:"bytes,4,rep,name=servers,proto3" json:"servers,omitempty"`
	Tags         []*OpenAPITag           `protobuf:"bytes,5,rep,name=tags,proto3" json:"tags,omitempty"`
	Paths        map[string]*OpenAPIPath `protobuf:"bytes,6,rep,name=paths,proto3" json:"paths,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Components   *OpenAPIComponents      `protobuf:"bytes,7,opt,name=components,proto3" json:"components,omitempty"`
}

func (m *OpenAPI) Reset()         { *m = OpenAPI{} }
func (m *OpenAPI) String() string { return proto.CompactTextString(m) }
func (*OpenAPI) ProtoMessage()    {}
func (*OpenAPI) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{2}
}
func (m *OpenAPI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenAPI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenAPI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenAPI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenAPI.Merge(m, src)
}
func (m *OpenAPI) XXX_Size() int {
	return m.XSize()
}
func (m *OpenAPI) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenAPI.DiscardUnknown(m)
}

var xxx_messageInfo_OpenAPI proto.InternalMessageInfo

type OpenAPIServer struct {
	Url         string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=Description,proto3" json:"Description,omitempty"`
}

func (m *OpenAPIServer) Reset()         { *m = OpenAPIServer{} }
func (m *OpenAPIServer) String() string { return proto.CompactTextString(m) }
func (*OpenAPIServer) ProtoMessage()    {}
func (*OpenAPIServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{3}
}
func (m *OpenAPIServer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenAPIServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenAPIServer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenAPIServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenAPIServer.Merge(m, src)
}
func (m *OpenAPIServer) XXX_Size() int {
	return m.XSize()
}
func (m *OpenAPIServer) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenAPIServer.DiscardUnknown(m)
}

var xxx_messageInfo_OpenAPIServer proto.InternalMessageInfo

type OpenAPIInfo struct {
	Title          string          `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description    string          `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	TermsOfService string          `protobuf:"bytes,3,opt,name=termsOfService,proto3" json:"termsOfService,omitempty"`
	Contact        *OpenAPIContact `protobuf:"bytes,4,opt,name=contact,proto3" json:"contact,omitempty"`
	License        *OpenAPILicense `protobuf:"bytes,5,opt,name=license,proto3" json:"license,omitempty"`
	Version        string          `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *OpenAPIInfo) Reset()         { *m = OpenAPIInfo{} }
func (m *OpenAPIInfo) String() string { return proto.CompactTextString(m) }
func (*OpenAPIInfo) ProtoMessage()    {}
func (*OpenAPIInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{4}
}
func (m *OpenAPIInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenAPIInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenAPIInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenAPIInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenAPIInfo.Merge(m, src)
}
func (m *OpenAPIInfo) XXX_Size() int {
	return m.XSize()
}
func (m *OpenAPIInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenAPIInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OpenAPIInfo proto.InternalMessageInfo

type OpenAPIContact struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Email string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
}

func (m *OpenAPIContact) Reset()         { *m = OpenAPIContact{} }
func (m *OpenAPIContact) String() string { return proto.CompactTextString(m) }
func (*OpenAPIContact) ProtoMessage()    {}
func (*OpenAPIContact) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{5}
}
func (m *OpenAPIContact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenAPIContact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenAPIContact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenAPIContact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenAPIContact.Merge(m, src)
}
func (m *OpenAPIContact) XXX_Size() int {
	return m.XSize()
}
func (m *OpenAPIContact) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenAPIContact.DiscardUnknown(m)
}

var xxx_messageInfo_OpenAPIContact proto.InternalMessageInfo

type OpenAPILicense struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Url  string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *OpenAPILicense) Reset()         { *m = OpenAPILicense{} }
func (m *OpenAPILicense) String() string { return proto.CompactTextString(m) }
func (*OpenAPILicense) ProtoMessage()    {}
func (*OpenAPILicense) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{6}
}
func (m *OpenAPILicense) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenAPILicense) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenAPILicense.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenAPILicense) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenAPILicense.Merge(m, src)
}
func (m *OpenAPILicense) XXX_Size() int {
	return m.XSize()
}
func (m *OpenAPILicense) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenAPILicense.DiscardUnknown(m)
}

var xxx_messageInfo_OpenAPILicense proto.InternalMessageInfo

type OpenAPITag struct {
	Name         string               `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description  string               `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	ExternalDocs *OpenAPIExternalDocs `protobuf:"bytes,3,opt,name=externalDocs,proto3" json:"externalDocs,omitempty"`
}

func (m *OpenAPITag) Reset()         { *m = OpenAPITag{} }
func (m *OpenAPITag) String() string { return proto.CompactTextString(m) }
func (*OpenAPITag) ProtoMessage()    {}
func (*OpenAPITag) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{7}
}
func (m *OpenAPITag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenAPITag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenAPITag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenAPITag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenAPITag.Merge(m, src)
}
func (m *OpenAPITag) XXX_Size() int {
	return m.XSize()
}
func (m *OpenAPITag) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenAPITag.DiscardUnknown(m)
}

var xxx_messageInfo_OpenAPITag proto.InternalMessageInfo

type OpenAPIExternalDocs struct {
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Url         string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *OpenAPIExternalDocs) Reset()         { *m = OpenAPIExternalDocs{} }
func (m *OpenAPIExternalDocs) String() string { return proto.CompactTextString(m) }
func (*OpenAPIExternalDocs) ProtoMessage()    {}
func (*OpenAPIExternalDocs) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{8}
}
func (m *OpenAPIExternalDocs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenAPIExternalDocs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenAPIExternalDocs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenAPIExternalDocs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenAPIExternalDocs.Merge(m, src)
}
func (m *OpenAPIExternalDocs) XXX_Size() int {
	return m.XSize()
}
func (m *OpenAPIExternalDocs) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenAPIExternalDocs.DiscardUnknown(m)
}

var xxx_messageInfo_OpenAPIExternalDocs proto.InternalMessageInfo

type OpenAPIPath struct {
	Get    *OpenAPIPathDocs `protobuf:"bytes,1,opt,name=get,proto3" json:"get,omitempty"`
	Post   *OpenAPIPathDocs `protobuf:"bytes,2,opt,name=post,proto3" json:"post,omitempty"`
	Put    *OpenAPIPathDocs `protobuf:"bytes,3,opt,name=put,proto3" json:"put,omitempty"`
	Patch  *OpenAPIPathDocs `protobuf:"bytes,4,opt,name=patch,proto3" json:"patch,omitempty"`
	Delete *OpenAPIPathDocs `protobuf:"bytes,5,opt,name=delete,proto3" json:"delete,omitempty"`
}

func (m *OpenAPIPath) Reset()         { *m = OpenAPIPath{} }
func (m *OpenAPIPath) String() string { return proto.CompactTextString(m) }
func (*OpenAPIPath) ProtoMessage()    {}
func (*OpenAPIPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{9}
}
func (m *OpenAPIPath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenAPIPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenAPIPath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenAPIPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenAPIPath.Merge(m, src)
}
func (m *OpenAPIPath) XXX_Size() int {
	return m.XSize()
}
func (m *OpenAPIPath) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenAPIPath.DiscardUnknown(m)
}

var xxx_messageInfo_OpenAPIPath proto.InternalMessageInfo

type OpenAPIPathDocs struct {
	Tags        []string                 `protobuf:"bytes,1,rep,name=tags,proto3" json:"tags,omitempty"`
	Summary     string                   `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
	Description string                   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	OperationId string                   `protobuf:"bytes,4,opt,name=operationId,proto3" json:"operationId,omitempty"`
	Deprecated  bool                     `protobuf:"varint,5,opt,name=deprecated,proto3" json:"deprecated,omitempty"`
	RequestBody *PathRequestBody         `protobuf:"bytes,6,opt,name=requestBody,proto3" json:"requestBody,omitempty"`
	Parameters  []*PathParameters        `protobuf:"bytes,7,rep,name=parameters,proto3" json:"parameters,omitempty"`
	Responses   map[string]*PathResponse `protobuf:"bytes,8,rep,name=responses,proto3" json:"responses,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Security    []*PathSecurity          `protobuf:"bytes,9,rep,name=security,proto3" json:"security,omitempty"`
}

func (m *OpenAPIPathDocs) Reset()         { *m = OpenAPIPathDocs{} }
func (m *OpenAPIPathDocs) String() string { return proto.CompactTextString(m) }
func (*OpenAPIPathDocs) ProtoMessage()    {}
func (*OpenAPIPathDocs) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{10}
}
func (m *OpenAPIPathDocs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenAPIPathDocs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenAPIPathDocs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenAPIPathDocs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenAPIPathDocs.Merge(m, src)
}
func (m *OpenAPIPathDocs) XXX_Size() int {
	return m.XSize()
}
func (m *OpenAPIPathDocs) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenAPIPathDocs.DiscardUnknown(m)
}

var xxx_messageInfo_OpenAPIPathDocs proto.InternalMessageInfo

type PathSecurity struct {
	Basic   []string `protobuf:"bytes,1,rep,name=basic,proto3" json:"basic,omitempty"`
	ApiKeys []string `protobuf:"bytes,2,rep,name=apiKeys,proto3" json:"apiKeys,omitempty"`
	Bearer  []string `protobuf:"bytes,3,rep,name=bearer,proto3" json:"bearer,omitempty"`
}

func (m *PathSecurity) Reset()         { *m = PathSecurity{} }
func (m *PathSecurity) String() string { return proto.CompactTextString(m) }
func (*PathSecurity) ProtoMessage()    {}
func (*PathSecurity) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{11}
}
func (m *PathSecurity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathSecurity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathSecurity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathSecurity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathSecurity.Merge(m, src)
}
func (m *PathSecurity) XXX_Size() int {
	return m.XSize()
}
func (m *PathSecurity) XXX_DiscardUnknown() {
	xxx_messageInfo_PathSecurity.DiscardUnknown(m)
}

var xxx_messageInfo_PathSecurity proto.InternalMessageInfo

type PathParameters struct {
	// query, cookie, path
	In              string  `protobuf:"bytes,1,opt,name=in,proto3" json:"in,omitempty"`
	Name            string  `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Required        bool    `protobuf:"varint,3,opt,name=required,proto3" json:"required,omitempty"`
	Description     string  `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	AllowReserved   bool    `protobuf:"varint,5,opt,name=allowReserved,proto3" json:"allowReserved,omitempty"`
	Style           string  `protobuf:"bytes,6,opt,name=style,proto3" json:"style,omitempty"`
	Explode         bool    `protobuf:"varint,7,opt,name=explode,proto3" json:"explode,omitempty"`
	AllowEmptyValue bool    `protobuf:"varint,8,opt,name=allowEmptyValue,proto3" json:"allowEmptyValue,omitempty"`
	Schema          *Schema `protobuf:"bytes,9,opt,name=schema,proto3" json:"schema,omitempty"`
	Example         string  `protobuf:"bytes,10,opt,name=example,proto3" json:"example,omitempty"`
}

func (m *PathParameters) Reset()         { *m = PathParameters{} }
func (m *PathParameters) String() string { return proto.CompactTextString(m) }
func (*PathParameters) ProtoMessage()    {}
func (*PathParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{12}
}
func (m *PathParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathParameters.Merge(m, src)
}
func (m *PathParameters) XXX_Size() int {
	return m.XSize()
}
func (m *PathParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_PathParameters.DiscardUnknown(m)
}

var xxx_messageInfo_PathParameters proto.InternalMessageInfo

type PathRequestBody struct {
	Description string                  `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Required    bool                    `protobuf:"varint,2,opt,name=required,proto3" json:"required,omitempty"`
	Content     *PathRequestBodyContent `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *PathRequestBody) Reset()         { *m = PathRequestBody{} }
func (m *PathRequestBody) String() string { return proto.CompactTextString(m) }
func (*PathRequestBody) ProtoMessage()    {}
func (*PathRequestBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{13}
}
func (m *PathRequestBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathRequestBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathRequestBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathRequestBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathRequestBody.Merge(m, src)
}
func (m *PathRequestBody) XXX_Size() int {
	return m.XSize()
}
func (m *PathRequestBody) XXX_DiscardUnknown() {
	xxx_messageInfo_PathRequestBody.DiscardUnknown(m)
}

var xxx_messageInfo_PathRequestBody proto.InternalMessageInfo

type PathRequestBodyContent struct {
	ApplicationJson *ApplicationContent `protobuf:"bytes,1,opt,name=applicationJson,proto3" json:"application/json,omitempty"`
	ApplicationXml  *ApplicationContent `protobuf:"bytes,2,opt,name=applicationXml,proto3" json:"application/xml,omitempty"`
}

func (m *PathRequestBodyContent) Reset()         { *m = PathRequestBodyContent{} }
func (m *PathRequestBodyContent) String() string { return proto.CompactTextString(m) }
func (*PathRequestBodyContent) ProtoMessage()    {}
func (*PathRequestBodyContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{14}
}
func (m *PathRequestBodyContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathRequestBodyContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathRequestBodyContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathRequestBodyContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathRequestBodyContent.Merge(m, src)
}
func (m *PathRequestBodyContent) XXX_Size() int {
	return m.XSize()
}
func (m *PathRequestBodyContent) XXX_DiscardUnknown() {
	xxx_messageInfo_PathRequestBodyContent.DiscardUnknown(m)
}

var xxx_messageInfo_PathRequestBodyContent proto.InternalMessageInfo

type ApplicationContent struct {
	Schema *Schema `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
}

func (m *ApplicationContent) Reset()         { *m = ApplicationContent{} }
func (m *ApplicationContent) String() string { return proto.CompactTextString(m) }
func (*ApplicationContent) ProtoMessage()    {}
func (*ApplicationContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{15}
}
func (m *ApplicationContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplicationContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplicationContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplicationContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationContent.Merge(m, src)
}
func (m *ApplicationContent) XXX_Size() int {
	return m.XSize()
}
func (m *ApplicationContent) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationContent.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationContent proto.InternalMessageInfo

// PathResponse is swagger path response
type PathResponse struct {
	Description string                  `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Content     *PathRequestBodyContent `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *PathResponse) Reset()         { *m = PathResponse{} }
func (m *PathResponse) String() string { return proto.CompactTextString(m) }
func (*PathResponse) ProtoMessage()    {}
func (*PathResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{16}
}
func (m *PathResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathResponse.Merge(m, src)
}
func (m *PathResponse) XXX_Size() int {
	return m.XSize()
}
func (m *PathResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PathResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PathResponse proto.InternalMessageInfo

type OpenAPIComponents struct {
	SecuritySchemes *SecuritySchemes  `protobuf:"bytes,1,opt,name=securitySchemes,proto3" json:"securitySchemes,omitempty"`
	Schemas         map[string]*Model `protobuf:"bytes,2,rep,name=schemas,proto3" json:"schemas,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *OpenAPIComponents) Reset()         { *m = OpenAPIComponents{} }
func (m *OpenAPIComponents) String() string { return proto.CompactTextString(m) }
func (*OpenAPIComponents) ProtoMessage()    {}
func (*OpenAPIComponents) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{17}
}
func (m *OpenAPIComponents) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenAPIComponents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenAPIComponents.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenAPIComponents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenAPIComponents.Merge(m, src)
}
func (m *OpenAPIComponents) XXX_Size() int {
	return m.XSize()
}
func (m *OpenAPIComponents) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenAPIComponents.DiscardUnknown(m)
}

var xxx_messageInfo_OpenAPIComponents proto.InternalMessageInfo

type SecuritySchemes struct {
	Basic   *BasicSecurity   `protobuf:"bytes,1,opt,name=basic,proto3" json:"basic,omitempty"`
	ApiKeys *APIKeysSecurity `protobuf:"bytes,2,opt,name=apiKeys,proto3" json:"apiKeys,omitempty"`
	Bearer  *BearerSecurity  `protobuf:"bytes,3,opt,name=bearer,proto3" json:"bearer,omitempty"`
}

func (m *SecuritySchemes) Reset()         { *m = SecuritySchemes{} }
func (m *SecuritySchemes) String() string { return proto.CompactTextString(m) }
func (*SecuritySchemes) ProtoMessage()    {}
func (*SecuritySchemes) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{18}
}
func (m *SecuritySchemes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecuritySchemes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecuritySchemes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecuritySchemes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecuritySchemes.Merge(m, src)
}
func (m *SecuritySchemes) XXX_Size() int {
	return m.XSize()
}
func (m *SecuritySchemes) XXX_DiscardUnknown() {
	xxx_messageInfo_SecuritySchemes.DiscardUnknown(m)
}

var xxx_messageInfo_SecuritySchemes proto.InternalMessageInfo

// BasicSecurity is swagger Basic Authorization security (https://swagger.io/docs/specification/authentication/basic-authentication/)
type BasicSecurity struct {
	// http, apiKey, oauth, openIdConnect
	Type   string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Scheme string `protobuf:"bytes,2,opt,name=scheme,proto3" json:"scheme,omitempty"`
}

func (m *BasicSecurity) Reset()         { *m = BasicSecurity{} }
func (m *BasicSecurity) String() string { return proto.CompactTextString(m) }
func (*BasicSecurity) ProtoMessage()    {}
func (*BasicSecurity) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{19}
}
func (m *BasicSecurity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicSecurity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicSecurity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicSecurity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicSecurity.Merge(m, src)
}
func (m *BasicSecurity) XXX_Size() int {
	return m.XSize()
}
func (m *BasicSecurity) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicSecurity.DiscardUnknown(m)
}

var xxx_messageInfo_BasicSecurity proto.InternalMessageInfo

// APIKeysSecurity is swagger API keys Authorization security (https://swagger.io/docs/specification/authentication/api-keys/)
type APIKeysSecurity struct {
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// header
	In   string `protobuf:"bytes,2,opt,name=in,proto3" json:"in,omitempty"`
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *APIKeysSecurity) Reset()         { *m = APIKeysSecurity{} }
func (m *APIKeysSecurity) String() string { return proto.CompactTextString(m) }
func (*APIKeysSecurity) ProtoMessage()    {}
func (*APIKeysSecurity) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{20}
}
func (m *APIKeysSecurity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *APIKeysSecurity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_APIKeysSecurity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *APIKeysSecurity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_APIKeysSecurity.Merge(m, src)
}
func (m *APIKeysSecurity) XXX_Size() int {
	return m.XSize()
}
func (m *APIKeysSecurity) XXX_DiscardUnknown() {
	xxx_messageInfo_APIKeysSecurity.DiscardUnknown(m)
}

var xxx_messageInfo_APIKeysSecurity proto.InternalMessageInfo

// BearerSecurity is swagger Bearer Authorization security (https://swagger.io/docs/specification/authentication/bearer-authentication/)
type BearerSecurity struct {
	// http
	Type   string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Scheme string `protobuf:"bytes,2,opt,name=scheme,proto3" json:"scheme,omitempty"`
	// JWT
	BearerFormat string `protobuf:"bytes,3,opt,name=bearerFormat,proto3" json:"bearerFormat,omitempty"`
}

func (m *BearerSecurity) Reset()         { *m = BearerSecurity{} }
func (m *BearerSecurity) String() string { return proto.CompactTextString(m) }
func (*BearerSecurity) ProtoMessage()    {}
func (*BearerSecurity) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{21}
}
func (m *BearerSecurity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerSecurity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerSecurity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerSecurity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerSecurity.Merge(m, src)
}
func (m *BearerSecurity) XXX_Size() int {
	return m.XSize()
}
func (m *BearerSecurity) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerSecurity.DiscardUnknown(m)
}

var xxx_messageInfo_BearerSecurity proto.InternalMessageInfo

// Model is swagger data models (https://swagger.io/docs/specification/data-models/)
type Model struct {
	// string, number, integer, boolean, array, object
	Type       string             `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Properties map[string]*Schema `protobuf:"bytes,2,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Required   []string           `protobuf:"bytes,3,rep,name=required,proto3" json:"required,omitempty"`
}

func (m *Model) Reset()         { *m = Model{} }
func (m *Model) String() string { return proto.CompactTextString(m) }
func (*Model) ProtoMessage()    {}
func (*Model) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{22}
}
func (m *Model) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model.Merge(m, src)
}
func (m *Model) XXX_Size() int {
	return m.XSize()
}
func (m *Model) XXX_DiscardUnknown() {
	xxx_messageInfo_Model.DiscardUnknown(m)
}

var xxx_messageInfo_Model proto.InternalMessageInfo

type Schema struct {
	Type                 string            `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Format               string            `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	Description          string            `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Example              string            `protobuf:"bytes,4,opt,name=example,proto3" json:"example,omitempty"`
	Pattern              string            `protobuf:"bytes,5,opt,name=pattern,proto3" json:"pattern,omitempty"`
	Nullable             bool              `protobuf:"varint,6,opt,name=nullable,proto3" json:"nullable,omitempty"`
	ReadOnly             bool              `protobuf:"varint,7,opt,name=readOnly,proto3" json:"readOnly,omitempty"`
	WriteOnly            bool              `protobuf:"varint,8,opt,name=writeOnly,proto3" json:"writeOnly,omitempty"`
	Required             bool              `protobuf:"varint,9,opt,name=required,proto3" json:"required,omitempty"`
	Ref                  string            `protobuf:"bytes,10,opt,name=ref,proto3" json:"$ref,omitempty"`
	Default              string            `protobuf:"bytes,11,opt,name=default,proto3" json:"default,omitempty"`
	MinLength            int32             `protobuf:"varint,20,opt,name=minLength,proto3" json:"minLength,omitempty"`
	MaxLength            int32             `protobuf:"varint,21,opt,name=maxLength,proto3" json:"maxLength,omitempty"`
	MultipleOf           int32             `protobuf:"varint,30,opt,name=multipleOf,proto3" json:"multipleOf,omitempty"`
	Minimum              int32             `protobuf:"varint,31,opt,name=minimum,proto3" json:"minimum,omitempty"`
	ExclusiveMinimum     bool              `protobuf:"varint,32,opt,name=exclusiveMinimum,proto3" json:"exclusiveMinimum,omitempty"`
	Maximum              int32             `protobuf:"varint,33,opt,name=maximum,proto3" json:"maximum,omitempty"`
	ExclusiveMaximum     bool              `protobuf:"varint,34,opt,name=exclusiveMaximum,proto3" json:"exclusiveMaximum,omitempty"`
	Enum                 []string          `protobuf:"bytes,41,rep,name=enum,proto3" json:"enum,omitempty"`
	Items                *Schema           `protobuf:"bytes,42,opt,name=items,proto3" json:"items,omitempty"`
	Parameters           []*PathParameters `protobuf:"bytes,51,rep,name=parameters,proto3" json:"parameters,omitempty"`
	AdditionalProperties *Schema           `protobuf:"bytes,60,opt,name=additionalProperties,proto3" json:"additionalProperties,omitempty"`
}

func (m *Schema) Reset()         { *m = Schema{} }
func (m *Schema) String() string { return proto.CompactTextString(m) }
func (*Schema) ProtoMessage()    {}
func (*Schema) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ef2934ade15a220, []int{23}
}
func (m *Schema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Schema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema.Merge(m, src)
}
func (m *Schema) XXX_Size() int {
	return m.XSize()
}
func (m *Schema) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema.DiscardUnknown(m)
}

var xxx_messageInfo_Schema proto.InternalMessageInfo

func init() {
	proto.RegisterType((*GetOpenAPIDocRequest)(nil), "openapi.GetOpenAPIDocRequest")
	proto.RegisterType((*GetOpenAPIDocResponse)(nil), "openapi.GetOpenAPIDocResponse")
	proto.RegisterType((*OpenAPI)(nil), "openapi.OpenAPI")
	proto.RegisterMapType((map[string]*OpenAPIPath)(nil), "openapi.OpenAPI.PathsEntry")
	proto.RegisterType((*OpenAPIServer)(nil), "openapi.OpenAPIServer")
	proto.RegisterType((*OpenAPIInfo)(nil), "openapi.OpenAPIInfo")
	proto.RegisterType((*OpenAPIContact)(nil), "openapi.OpenAPIContact")
	proto.RegisterType((*OpenAPILicense)(nil), "openapi.OpenAPILicense")
	proto.RegisterType((*OpenAPITag)(nil), "openapi.OpenAPITag")
	proto.RegisterType((*OpenAPIExternalDocs)(nil), "openapi.OpenAPIExternalDocs")
	proto.RegisterType((*OpenAPIPath)(nil), "openapi.OpenAPIPath")
	proto.RegisterType((*OpenAPIPathDocs)(nil), "openapi.OpenAPIPathDocs")
	proto.RegisterMapType((map[string]*PathResponse)(nil), "openapi.OpenAPIPathDocs.ResponsesEntry")
	proto.RegisterType((*PathSecurity)(nil), "openapi.PathSecurity")
	proto.RegisterType((*PathParameters)(nil), "openapi.PathParameters")
	proto.RegisterType((*PathRequestBody)(nil), "openapi.PathRequestBody")
	proto.RegisterType((*PathRequestBodyContent)(nil), "openapi.PathRequestBodyContent")
	proto.RegisterType((*ApplicationContent)(nil), "openapi.ApplicationContent")
	proto.RegisterType((*PathResponse)(nil), "openapi.PathResponse")
	proto.RegisterType((*OpenAPIComponents)(nil), "openapi.OpenAPIComponents")
	proto.RegisterMapType((map[string]*Model)(nil), "openapi.OpenAPIComponents.SchemasEntry")
	proto.RegisterType((*SecuritySchemes)(nil), "openapi.SecuritySchemes")
	proto.RegisterType((*BasicSecurity)(nil), "openapi.BasicSecurity")
	proto.RegisterType((*APIKeysSecurity)(nil), "openapi.APIKeysSecurity")
	proto.RegisterType((*BearerSecurity)(nil), "openapi.BearerSecurity")
	proto.RegisterType((*Model)(nil), "openapi.Model")
	proto.RegisterMapType((map[string]*Schema)(nil), "openapi.Model.PropertiesEntry")
	proto.RegisterType((*Schema)(nil), "openapi.Schema")
}

func init() {
	proto.RegisterFile("github.com/vine-io/vine/lib/api/handler/openapi/proto/openapi.proto", fileDescriptor_1ef2934ade15a220)
}

var fileDescriptor_1ef2934ade15a220 = []byte{
	// 1566 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0x4b, 0x73, 0x1b, 0xc5,
	0x13, 0xf7, 0xea, 0x61, 0x49, 0x2d, 0x5b, 0xf2, 0x7f, 0x62, 0x3b, 0x5b, 0xfe, 0x07, 0xc5, 0x6c,
	0x05, 0x62, 0x4c, 0xb0, 0x13, 0xa7, 0x8a, 0x87, 0x43, 0x28, 0x6c, 0xc7, 0x50, 0x0e, 0x49, 0xec,
	0x5a, 0x53, 0x29, 0x0a, 0x2e, 0x19, 0xaf, 0x46, 0xf6, 0x54, 0xf6, 0xc5, 0xee, 0xac, 0x63, 0xdd,
	0x39, 0x71, 0xe2, 0x43, 0xe4, 0xc2, 0x07, 0xe0, 0x33, 0x10, 0x6e, 0x39, 0x72, 0x84, 0xa4, 0x0a,
	0x4e, 0x1c, 0xb9, 0x53, 0xf3, 0x5a, 0xed, 0xae, 0x56, 0x79, 0xc0, 0xc9, 0xdb, 0xdd, 0xbf, 0xee,
	0x99, 0xee, 0xe9, 0xf9, 0xf5, 0x58, 0xb0, 0x73, 0x4c, 0xd9, 0x49, 0x72, 0xb4, 0xe6, 0x04, 0xde,
	0xfa, 0x29, 0xf5, 0xc9, 0x7b, 0x34, 0x10, 0x7f, 0xd7, 0x5d, 0x7a, 0xb4, 0x8e, 0x43, 0xba, 0x7e,
	0x82, 0xfd, 0xbe, 0x4b, 0xa2, 0xf5, 0x20, 0x24, 0x3e, 0x97, 0xc3, 0x28, 0x60, 0x81, 0x96, 0xd6,
	0x84, 0x84, 0x1a, 0x4a, 0xb4, 0x16, 0x61, 0xfe, 0x73, 0xc2, 0xf6, 0x43, 0xe2, 0x6f, 0x1d, 0xec,
	0xdd, 0x0a, 0x1c, 0x9b, 0x7c, 0x9b, 0x90, 0x98, 0x59, 0x37, 0x61, 0xa1, 0xa0, 0x8f, 0xc3, 0xc0,
	0x8f, 0x09, 0xba, 0x04, 0x35, 0x1c, 0xd2, 0xd8, 0x34, 0x96, 0xab, 0x2b, 0xed, 0x8d, 0xb9, 0x35,
	0x1d, 0x57, 0x41, 0x6d, 0x61, 0xb5, 0x7e, 0xac, 0x42, 0x43, 0x69, 0x90, 0x09, 0x7a, 0x35, 0xd3,
	0x58, 0x36, 0x56, 0x5a, 0xb6, 0x16, 0xd1, 0x0a, 0xd4, 0xa8, 0x3f, 0x08, 0xcc, 0xca, 0xb2, 0xb1,
	0xd2, 0xde, 0x98, 0x2f, 0xc6, 0xda, 0xf3, 0x07, 0x81, 0x2d, 0x10, 0xe8, 0x53, 0x98, 0x21, 0x67,
	0x8c, 0x44, 0x3e, 0x76, 0x6f, 0x05, 0x4e, 0x6c, 0x56, 0x85, 0xc7, 0x85, 0xa2, 0xc7, 0x6e, 0x06,
	0x63, 0xe7, 0x3c, 0xd0, 0x55, 0x68, 0xc4, 0x24, 0x3a, 0x25, 0x51, 0x6c, 0xd6, 0xc4, 0xd6, 0x17,
	0x8b, 0xce, 0x87, 0xc2, 0x6c, 0x6b, 0x18, 0xba, 0x0c, 0x35, 0x86, 0x8f, 0x63, 0xb3, 0x2e, 0xe0,
	0xe7, 0x8a, 0xf0, 0x2f, 0xf1, 0xb1, 0x2d, 0x00, 0xe8, 0x1a, 0xd4, 0x43, 0xcc, 0x4e, 0x62, 0x73,
	0x5a, 0x20, 0xff, 0x5f, 0x44, 0xae, 0x1d, 0x70, 0xeb, 0xae, 0xcf, 0xa2, 0xa1, 0x2d, 0x91, 0x68,
	0x13, 0xc0, 0x09, 0xbc, 0x30, 0xf0, 0x89, 0xcf, 0x62, 0xb3, 0x21, 0xb2, 0x59, 0x2a, 0xfa, 0xed,
	0xa4, 0x08, 0x3b, 0x83, 0x5e, 0xba, 0x07, 0x30, 0x0a, 0x88, 0xe6, 0xa0, 0xfa, 0x90, 0x0c, 0x55,
	0x65, 0xf9, 0x27, 0x5a, 0x85, 0xfa, 0x29, 0x76, 0x13, 0x32, 0xa9, 0xac, 0xdc, 0xd9, 0x96, 0x90,
	0xcd, 0xca, 0x87, 0x86, 0xb5, 0x03, 0xb3, 0xb9, 0x0a, 0xf0, 0x90, 0x49, 0xe4, 0xea, 0x90, 0x49,
	0xe4, 0xa2, 0x65, 0x68, 0xdf, 0x22, 0xb1, 0x13, 0xd1, 0x90, 0xd1, 0xc0, 0x17, 0x81, 0x5b, 0x76,
	0x56, 0x65, 0xfd, 0x65, 0x40, 0x3b, 0x73, 0x6c, 0x68, 0x1e, 0xea, 0x8c, 0x32, 0x97, 0xa8, 0x28,
	0x52, 0xe0, 0x71, 0xfa, 0xe3, 0x71, 0x32, 0x2a, 0xf4, 0x36, 0x74, 0x18, 0x89, 0xbc, 0x78, 0x7f,
	0xc0, 0x37, 0x43, 0x1d, 0x22, 0x8e, 0xba, 0x65, 0x17, 0xb4, 0xe8, 0x1a, 0x34, 0x9c, 0xc0, 0x67,
	0xd8, 0x61, 0x66, 0x4d, 0xa4, 0x79, 0x7e, 0xbc, 0x7a, 0xc2, 0x6c, 0x6b, 0x1c, 0x77, 0x71, 0xa9,
	0x43, 0xfc, 0x98, 0x98, 0xf5, 0x72, 0x97, 0x3b, 0xd2, 0x6c, 0x6b, 0x1c, 0x6f, 0x5d, 0xde, 0x0a,
	0x7c, 0xaf, 0xd3, 0xb2, 0x75, 0x95, 0x68, 0x6d, 0x42, 0x27, 0xbf, 0x0e, 0x42, 0x50, 0xf3, 0xb1,
	0xa7, 0x13, 0x16, 0xdf, 0xbc, 0x0a, 0xc4, 0xc3, 0xd4, 0x55, 0x99, 0x4a, 0xc1, 0x7a, 0x3f, 0xf5,
	0x55, 0x0b, 0x96, 0xfa, 0xaa, 0x53, 0xa8, 0xa4, 0xa7, 0x60, 0x7d, 0x67, 0x00, 0x8c, 0x9a, 0xaf,
	0xd4, 0xe9, 0xe5, 0x05, 0xfe, 0xcf, 0x37, 0xc9, 0xda, 0x83, 0x73, 0x25, 0xa0, 0xe2, 0xd2, 0xc6,
	0xf8, 0xd2, 0xe3, 0x19, 0xfd, 0x3d, 0xea, 0x1a, 0xde, 0x95, 0x68, 0x15, 0xaa, 0xc7, 0x84, 0x09,
	0xdf, 0xf6, 0x86, 0x59, 0xd6, 0xb8, 0x62, 0x3f, 0x1c, 0x84, 0xae, 0x40, 0x2d, 0x0c, 0x62, 0xa6,
	0xba, 0x7c, 0x32, 0x58, 0xa0, 0x78, 0xe4, 0x30, 0x61, 0x2a, 0xdb, 0x17, 0x44, 0x0e, 0x13, 0x86,
	0xd6, 0xc4, 0x7d, 0x76, 0x4e, 0x54, 0x67, 0x4d, 0x46, 0x4b, 0x18, 0xba, 0x0a, 0xd3, 0x7d, 0xe2,
	0x12, 0xa6, 0xfb, 0x6a, 0xb2, 0x83, 0xc2, 0x59, 0x7f, 0x56, 0xa1, 0x5b, 0xb0, 0xf1, 0xe3, 0x14,
	0x74, 0xc3, 0x89, 0xb5, 0xa5, 0x98, 0xc5, 0x84, 0x46, 0x9c, 0x78, 0x1e, 0x8e, 0x86, 0xaa, 0x6a,
	0x5a, 0x2c, 0x56, 0xbb, 0x3a, 0x5e, 0xed, 0x65, 0x68, 0x07, 0x21, 0x89, 0x30, 0x17, 0xf6, 0xfa,
	0x22, 0x97, 0x96, 0x9d, 0x55, 0xa1, 0x1e, 0x40, 0x9f, 0x84, 0x11, 0x71, 0x30, 0x23, 0x7d, 0xb1,
	0xf7, 0xa6, 0x9d, 0xd1, 0xa0, 0x4d, 0x68, 0x47, 0x72, 0x1c, 0x6c, 0x07, 0xfd, 0xa1, 0xb8, 0x01,
	0xd9, 0xe4, 0x04, 0x8f, 0x8c, 0xec, 0x76, 0x16, 0x8c, 0x3e, 0x00, 0x08, 0x71, 0x84, 0x3d, 0xc2,
	0x38, 0xe3, 0x36, 0x04, 0x31, 0x9e, 0xcf, 0xb9, 0x1e, 0xa4, 0x66, 0x3b, 0x03, 0x45, 0xbb, 0xd0,
	0x8a, 0xd4, 0xac, 0x89, 0xcd, 0xa6, 0xf0, 0xbb, 0x3c, 0xa9, 0x9e, 0x6b, 0x7a, 0x2a, 0x29, 0x72,
	0x1d, 0x79, 0xa2, 0x6b, 0xd0, 0x8c, 0x89, 0x93, 0x44, 0x94, 0x0d, 0xcd, 0x96, 0x88, 0xb2, 0x90,
	0x5b, 0xfd, 0x50, 0x19, 0xed, 0x14, 0xb6, 0x74, 0x08, 0x9d, 0x7c, 0xbc, 0x12, 0x6e, 0x7d, 0x37,
	0xcf, 0xad, 0x0b, 0x85, 0x62, 0x48, 0xef, 0x2c, 0xb9, 0xde, 0x87, 0x99, 0xec, 0x72, 0x9c, 0x11,
	0x8e, 0x70, 0x4c, 0x1d, 0x75, 0xcc, 0x52, 0xe0, 0xe7, 0x8c, 0x43, 0xfa, 0x05, 0x19, 0xc6, 0x66,
	0x45, 0xe8, 0xb5, 0x88, 0x16, 0x61, 0xfa, 0x88, 0xe0, 0x88, 0x44, 0x66, 0x55, 0x18, 0x94, 0x64,
	0xfd, 0x54, 0x81, 0x4e, 0xbe, 0x8a, 0xa8, 0x03, 0x15, 0xaa, 0xef, 0x5d, 0x85, 0xfa, 0x29, 0x3f,
	0x54, 0x32, 0xfc, 0xb0, 0x04, 0x4d, 0x7e, 0x4a, 0x34, 0x22, 0x7d, 0xd1, 0x33, 0x4d, 0x3b, 0x95,
	0x8b, 0x2d, 0x55, 0x1b, 0x6f, 0xa9, 0x4b, 0x30, 0x8b, 0x5d, 0x37, 0x78, 0x64, 0x13, 0x31, 0x23,
	0x75, 0xcf, 0xe4, 0x95, 0x3c, 0xc5, 0x98, 0x0d, 0x5d, 0xa2, 0x28, 0x53, 0x0a, 0x3c, 0x45, 0x72,
	0x16, 0xba, 0x41, 0x9f, 0x88, 0x71, 0xd7, 0xb4, 0xb5, 0x88, 0x56, 0xa0, 0x2b, 0x02, 0xec, 0x7a,
	0x21, 0x1b, 0xde, 0x17, 0xd5, 0x6d, 0x0a, 0x44, 0x51, 0x8d, 0x2e, 0xc3, 0x74, 0xec, 0x9c, 0x10,
	0x0f, 0x9b, 0x2d, 0x51, 0xfe, 0x6e, 0x5a, 0xfe, 0x43, 0xa1, 0xb6, 0x95, 0x59, 0x2e, 0x86, 0xbd,
	0xd0, 0x25, 0x26, 0xc8, 0x7b, 0xa3, 0x44, 0xeb, 0x7b, 0x03, 0xba, 0x85, 0xc6, 0x7d, 0x05, 0xe6,
	0xca, 0x96, 0xad, 0x52, 0x28, 0xdb, 0x47, 0x72, 0x12, 0x11, 0x5f, 0xb3, 0xcb, 0xc5, 0x49, 0x37,
	0x64, 0x47, 0xc2, 0x6c, 0x8d, 0xb7, 0x1e, 0x1b, 0xb0, 0x58, 0x8e, 0x41, 0xbb, 0xd0, 0xc5, 0x61,
	0xe8, 0x52, 0x47, 0x5c, 0xd6, 0xdb, 0xb1, 0xda, 0x57, 0xf6, 0x75, 0xb1, 0x35, 0xb2, 0xeb, 0xc8,
	0x45, 0x1f, 0xb4, 0x03, 0x9d, 0x8c, 0xea, 0x2b, 0xcf, 0x55, 0x8d, 0xfb, 0xc2, 0x28, 0x05, 0x17,
	0xeb, 0x26, 0xa0, 0x71, 0x54, 0xe6, 0x30, 0x8c, 0x17, 0x1e, 0x86, 0xf5, 0x50, 0x5e, 0x81, 0xf4,
	0x05, 0xf9, 0xf2, 0x72, 0x67, 0x4a, 0x5a, 0x79, 0xcd, 0x92, 0xfe, 0x61, 0xc0, 0xff, 0xc6, 0x9e,
	0x4f, 0x68, 0x1b, 0xba, 0xfa, 0x9a, 0x8b, 0xcd, 0x91, 0x78, 0x6c, 0xc6, 0x1c, 0xe6, 0xed, 0x76,
	0xd1, 0x01, 0x6d, 0x41, 0x43, 0x26, 0x24, 0xef, 0x68, 0x09, 0x2d, 0x8d, 0x16, 0x54, 0x25, 0x50,
	0xb4, 0xa4, 0xfd, 0x96, 0x6e, 0xc3, 0x4c, 0xd6, 0x50, 0xc2, 0x2f, 0x97, 0xf2, 0xfc, 0xd2, 0x49,
	0x97, 0xb8, 0x1b, 0xf4, 0x89, 0x9b, 0x25, 0x96, 0xc7, 0x06, 0x74, 0x0b, 0x7b, 0x46, 0x57, 0x46,
	0xe4, 0x62, 0xe4, 0x5e, 0xb8, 0xdb, 0x5c, 0x9b, 0x52, 0x9e, 0x22, 0x9d, 0x8d, 0x2c, 0xe9, 0xe4,
	0x8b, 0xb1, 0x75, 0xb0, 0xc7, 0xf5, 0xa9, 0x47, 0x4a, 0x47, 0xeb, 0x19, 0x3a, 0xca, 0x3f, 0xa1,
	0xb6, 0x85, 0x3a, 0xf5, 0xd0, 0x3c, 0x75, 0x03, 0x66, 0x73, 0x8b, 0x8b, 0x31, 0x37, 0x0c, 0xd3,
	0x57, 0x0b, 0xff, 0xe6, 0x24, 0x27, 0x4a, 0xa4, 0xb9, 0x4a, 0x49, 0xd6, 0x1e, 0x74, 0x0b, 0x3b,
	0x29, 0x75, 0x97, 0xc4, 0x57, 0x19, 0x23, 0xbe, 0xea, 0x88, 0xf8, 0xac, 0x07, 0xd0, 0xc9, 0xef,
	0xf0, 0x75, 0x36, 0x82, 0x2c, 0x98, 0x91, 0xf9, 0x7c, 0x16, 0x44, 0x1e, 0x66, 0x2a, 0x72, 0x4e,
	0x67, 0xfd, 0x6c, 0x40, 0x5d, 0x9c, 0x52, 0x69, 0xe4, 0x4f, 0x00, 0xc2, 0x88, 0x0f, 0x5f, 0x46,
	0x89, 0x6e, 0xa0, 0x5e, 0xfe, 0x74, 0xd7, 0x0e, 0x52, 0x80, 0xec, 0x9b, 0x8c, 0x47, 0x81, 0xb8,
	0xf9, 0x24, 0x48, 0xe5, 0xa5, 0x7b, 0xd0, 0x2d, 0xb8, 0x96, 0x74, 0xd6, 0x5b, 0xf9, 0xce, 0x1a,
	0xbb, 0xad, 0x99, 0xd6, 0xfa, 0xa5, 0x0e, 0xd3, 0x52, 0x3b, 0xa9, 0x48, 0x03, 0x59, 0x06, 0x55,
	0x24, 0x29, 0xbd, 0xc2, 0x93, 0x24, 0x43, 0xcb, 0xb5, 0x1c, 0x2d, 0x73, 0x4b, 0x88, 0x19, 0x7f,
	0x4d, 0x8a, 0x99, 0xd2, 0xb2, 0xb5, 0xc8, 0x13, 0xf7, 0x13, 0xd7, 0xc5, 0x47, 0x6a, 0xa0, 0x34,
	0xed, 0x54, 0x96, 0x45, 0xc1, 0xfd, 0x7d, 0xdf, 0x1d, 0xaa, 0xa1, 0x92, 0xca, 0xe8, 0x02, 0xb4,
	0x1e, 0x45, 0x94, 0x11, 0x61, 0x94, 0xf3, 0x64, 0xa4, 0xc8, 0x95, 0xb3, 0x55, 0x20, 0xf4, 0x39,
	0xa8, 0x46, 0x64, 0xa0, 0x06, 0x07, 0xff, 0xe4, 0xbb, 0xeb, 0x93, 0x01, 0x4e, 0x5c, 0x66, 0xb6,
	0xe5, 0xee, 0x94, 0xc8, 0x57, 0xf1, 0xa8, 0x7f, 0x87, 0xf8, 0xc7, 0xec, 0xc4, 0x9c, 0x5f, 0x36,
	0x56, 0xea, 0xf6, 0x48, 0x21, 0xac, 0xf8, 0x4c, 0x59, 0x17, 0x94, 0x55, 0x2b, 0xf8, 0xf3, 0xcb,
	0x4b, 0x5c, 0x46, 0x43, 0x97, 0xec, 0x0f, 0xcc, 0x9e, 0x30, 0x67, 0x34, 0x7c, 0x55, 0x8f, 0xfa,
	0xd4, 0x4b, 0x3c, 0xf3, 0xa2, 0x30, 0x6a, 0x11, 0xad, 0xc2, 0x1c, 0x39, 0x73, 0xdc, 0x24, 0xa6,
	0xa7, 0xe4, 0xae, 0x82, 0x2c, 0x8b, 0x2c, 0xc6, 0xf4, 0x22, 0x0a, 0x3e, 0x13, 0x90, 0x37, 0x55,
	0x14, 0x29, 0xe6, 0xa3, 0x28, 0x88, 0x55, 0x8c, 0xa2, 0xb0, 0x08, 0x6a, 0xc4, 0x4f, 0x3c, 0xf3,
	0x1d, 0xf9, 0x38, 0xe5, 0xdf, 0xbc, 0xa3, 0x28, 0x23, 0x5e, 0x6c, 0xae, 0x4e, 0xe8, 0x28, 0x61,
	0x2d, 0xbc, 0x04, 0xaf, 0xbf, 0xfa, 0x4b, 0x70, 0x07, 0xe6, 0x71, 0xbf, 0x4f, 0x79, 0xe7, 0x60,
	0x77, 0xd4, 0xe0, 0xe6, 0xc7, 0xe5, 0xcb, 0x95, 0x82, 0x37, 0x1e, 0xa4, 0xff, 0x6b, 0xe9, 0xff,
	0x1c, 0xef, 0xc1, 0x6c, 0xee, 0x97, 0x0d, 0xf4, 0x46, 0x1a, 0xa9, 0xec, 0x97, 0x90, 0xa5, 0xde,
	0x24, 0xb3, 0x1c, 0x67, 0xdb, 0xdf, 0x3c, 0xf9, 0xbd, 0x37, 0xf5, 0xe4, 0x59, 0xcf, 0x78, 0xfa,
	0xac, 0x67, 0xfc, 0xf6, 0xac, 0x67, 0xfc, 0xf0, 0xbc, 0x37, 0xf5, 0xf4, 0x79, 0x6f, 0xea, 0xd7,
	0xe7, 0xbd, 0xa9, 0xaf, 0x6f, 0xfe, 0xab, 0x5f, 0x6b, 0x6e, 0x28, 0xe9, 0x68, 0x5a, 0x88, 0xd7,
	0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0x36, 0xf7, 0x93, 0x6f, 0xf5, 0x11, 0x00, 0x00,
}

func (m *GetOpenAPIDocRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetOpenAPIDocResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Apis) > 0 {
		for _, e := range m.Apis {
			l = e.XSize()
			n += 1 + l + sovOpenapi(uint64(l))
		}
	}
	return n
}

func (m *OpenAPI) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Openapi)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.ExternalDocs != nil {
		l = m.ExternalDocs.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if len(m.Servers) > 0 {
		for _, e := range m.Servers {
			l = e.XSize()
			n += 1 + l + sovOpenapi(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.XSize()
			n += 1 + l + sovOpenapi(uint64(l))
		}
	}
	if len(m.Paths) > 0 {
		for k, v := range m.Paths {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.XSize()
				l += 1 + sovOpenapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovOpenapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovOpenapi(uint64(mapEntrySize))
		}
	}
	if m.Components != nil {
		l = m.Components.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *OpenAPIServer) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *OpenAPIInfo) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.TermsOfService)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.Contact != nil {
		l = m.Contact.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.License != nil {
		l = m.License.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *OpenAPIContact) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *OpenAPILicense) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *OpenAPITag) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.ExternalDocs != nil {
		l = m.ExternalDocs.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *OpenAPIExternalDocs) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *OpenAPIPath) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.Post != nil {
		l = m.Post.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.Put != nil {
		l = m.Put.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.Patch != nil {
		l = m.Patch.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.Delete != nil {
		l = m.Delete.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *OpenAPIPathDocs) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovOpenapi(uint64(l))
		}
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.OperationId)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.Deprecated {
		n += 2
	}
	if m.RequestBody != nil {
		l = m.RequestBody.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.XSize()
			n += 1 + l + sovOpenapi(uint64(l))
		}
	}
	if len(m.Responses) > 0 {
		for k, v := range m.Responses {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.XSize()
				l += 1 + sovOpenapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovOpenapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovOpenapi(uint64(mapEntrySize))
		}
	}
	if len(m.Security) > 0 {
		for _, e := range m.Security {
			l = e.XSize()
			n += 1 + l + sovOpenapi(uint64(l))
		}
	}
	return n
}

func (m *PathSecurity) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Basic) > 0 {
		for _, s := range m.Basic {
			l = len(s)
			n += 1 + l + sovOpenapi(uint64(l))
		}
	}
	if len(m.ApiKeys) > 0 {
		for _, s := range m.ApiKeys {
			l = len(s)
			n += 1 + l + sovOpenapi(uint64(l))
		}
	}
	if len(m.Bearer) > 0 {
		for _, s := range m.Bearer {
			l = len(s)
			n += 1 + l + sovOpenapi(uint64(l))
		}
	}
	return n
}

func (m *PathParameters) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.In)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.Required {
		n += 2
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.AllowReserved {
		n += 2
	}
	l = len(m.Style)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.Explode {
		n += 2
	}
	if m.AllowEmptyValue {
		n += 2
	}
	if m.Schema != nil {
		l = m.Schema.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Example)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *PathRequestBody) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.Required {
		n += 2
	}
	if m.Content != nil {
		l = m.Content.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *PathRequestBodyContent) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApplicationJson != nil {
		l = m.ApplicationJson.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.ApplicationXml != nil {
		l = m.ApplicationXml.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *ApplicationContent) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Schema != nil {
		l = m.Schema.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *PathResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.Content != nil {
		l = m.Content.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *OpenAPIComponents) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SecuritySchemes != nil {
		l = m.SecuritySchemes.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if len(m.Schemas) > 0 {
		for k, v := range m.Schemas {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.XSize()
				l += 1 + sovOpenapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovOpenapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovOpenapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SecuritySchemes) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Basic != nil {
		l = m.Basic.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.ApiKeys != nil {
		l = m.ApiKeys.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.Bearer != nil {
		l = m.Bearer.XSize()
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *BasicSecurity) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Scheme)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *APIKeysSecurity) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.In)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *BearerSecurity) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Scheme)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.BearerFormat)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	return n
}

func (m *Model) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.XSize()
				l += 1 + sovOpenapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovOpenapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovOpenapi(uint64(mapEntrySize))
		}
	}
	if len(m.Required) > 0 {
		for _, s := range m.Required {
			l = len(s)
			n += 1 + l + sovOpenapi(uint64(l))
		}
	}
	return n
}

func (m *Schema) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Example)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.Nullable {
		n += 2
	}
	if m.ReadOnly {
		n += 2
	}
	if m.WriteOnly {
		n += 2
	}
	if m.Required {
		n += 2
	}
	l = len(m.Ref)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	l = len(m.Default)
	if l > 0 {
		n += 1 + l + sovOpenapi(uint64(l))
	}
	if m.MinLength != 0 {
		n += 2 + sovOpenapi(uint64(m.MinLength))
	}
	if m.MaxLength != 0 {
		n += 2 + sovOpenapi(uint64(m.MaxLength))
	}
	if m.MultipleOf != 0 {
		n += 2 + sovOpenapi(uint64(m.MultipleOf))
	}
	if m.Minimum != 0 {
		n += 2 + sovOpenapi(uint64(m.Minimum))
	}
	if m.ExclusiveMinimum {
		n += 3
	}
	if m.Maximum != 0 {
		n += 2 + sovOpenapi(uint64(m.Maximum))
	}
	if m.ExclusiveMaximum {
		n += 3
	}
	if len(m.Enum) > 0 {
		for _, s := range m.Enum {
			l = len(s)
			n += 2 + l + sovOpenapi(uint64(l))
		}
	}
	if m.Items != nil {
		l = m.Items.XSize()
		n += 2 + l + sovOpenapi(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.XSize()
			n += 2 + l + sovOpenapi(uint64(l))
		}
	}
	if m.AdditionalProperties != nil {
		l = m.AdditionalProperties.XSize()
		n += 2 + l + sovOpenapi(uint64(l))
	}
	return n
}

func sovOpenapi(x uint64) (n int) {
	return (bits.Len64(x|1) + 6) / 7
}
func sozOpenapi(x uint64) (n int) {
	return sovOpenapi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetOpenAPIDocRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOpenAPIDocRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOpenAPIDocRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetOpenAPIDocResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOpenAPIDocResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOpenAPIDocResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Apis) > 0 {
		for iNdEx := len(m.Apis) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Apis[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOpenapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OpenAPI) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenAPI) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenAPI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Components != nil {
		{
			size, err := m.Components.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Paths) > 0 {
		for k := range m.Paths {
			v := m.Paths[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOpenapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintOpenapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintOpenapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOpenapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Servers) > 0 {
		for iNdEx := len(m.Servers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Servers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOpenapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ExternalDocs != nil {
		{
			size, err := m.ExternalDocs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Openapi) > 0 {
		i -= len(m.Openapi)
		copy(dAtA[i:], m.Openapi)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Openapi)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenAPIServer) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenAPIServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenAPIServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenAPIInfo) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenAPIInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenAPIInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x32
	}
	if m.License != nil {
		{
			size, err := m.License.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Contact != nil {
		{
			size, err := m.Contact.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.TermsOfService) > 0 {
		i -= len(m.TermsOfService)
		copy(dAtA[i:], m.TermsOfService)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.TermsOfService)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenAPIContact) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenAPIContact) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenAPIContact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenAPILicense) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenAPILicense) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenAPILicense) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenAPITag) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenAPITag) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenAPITag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExternalDocs != nil {
		{
			size, err := m.ExternalDocs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenAPIExternalDocs) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenAPIExternalDocs) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenAPIExternalDocs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenAPIPath) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenAPIPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenAPIPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Delete != nil {
		{
			size, err := m.Delete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Patch != nil {
		{
			size, err := m.Patch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Put != nil {
		{
			size, err := m.Put.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Post != nil {
		{
			size, err := m.Post.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Get != nil {
		{
			size, err := m.Get.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenAPIPathDocs) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenAPIPathDocs) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenAPIPathDocs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Security) > 0 {
		for iNdEx := len(m.Security) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Security[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOpenapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Responses) > 0 {
		for k := range m.Responses {
			v := m.Responses[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOpenapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintOpenapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintOpenapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOpenapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.RequestBody != nil {
		{
			size, err := m.RequestBody.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Deprecated {
		i--
		if m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.OperationId) > 0 {
		i -= len(m.OperationId)
		copy(dAtA[i:], m.OperationId)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.OperationId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Summary) > 0 {
		i -= len(m.Summary)
		copy(dAtA[i:], m.Summary)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Summary)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PathSecurity) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathSecurity) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathSecurity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bearer) > 0 {
		for iNdEx := len(m.Bearer) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Bearer[iNdEx])
			copy(dAtA[i:], m.Bearer[iNdEx])
			i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Bearer[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ApiKeys) > 0 {
		for iNdEx := len(m.ApiKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ApiKeys[iNdEx])
			copy(dAtA[i:], m.ApiKeys[iNdEx])
			i = encodeVarintOpenapi(dAtA, i, uint64(len(m.ApiKeys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Basic) > 0 {
		for iNdEx := len(m.Basic) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Basic[iNdEx])
			copy(dAtA[i:], m.Basic[iNdEx])
			i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Basic[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PathParameters) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Example) > 0 {
		i -= len(m.Example)
		copy(dAtA[i:], m.Example)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Example)))
		i--
		dAtA[i] = 0x52
	}
	if m.Schema != nil {
		{
			size, err := m.Schema.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.AllowEmptyValue {
		i--
		if m.AllowEmptyValue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Explode {
		i--
		if m.Explode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Style) > 0 {
		i -= len(m.Style)
		copy(dAtA[i:], m.Style)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Style)))
		i--
		dAtA[i] = 0x32
	}
	if m.AllowReserved {
		i--
		if m.AllowReserved {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if m.Required {
		i--
		if m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.In) > 0 {
		i -= len(m.In)
		copy(dAtA[i:], m.In)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.In)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PathRequestBody) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathRequestBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathRequestBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		{
			size, err := m.Content.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Required {
		i--
		if m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PathRequestBodyContent) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathRequestBodyContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathRequestBodyContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApplicationXml != nil {
		{
			size, err := m.ApplicationXml.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApplicationJson != nil {
		{
			size, err := m.ApplicationJson.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApplicationContent) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplicationContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Schema != nil {
		{
			size, err := m.Schema.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PathResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		{
			size, err := m.Content.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenAPIComponents) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenAPIComponents) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenAPIComponents) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Schemas) > 0 {
		for k := range m.Schemas {
			v := m.Schemas[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOpenapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintOpenapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintOpenapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.SecuritySchemes != nil {
		{
			size, err := m.SecuritySchemes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecuritySchemes) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecuritySchemes) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecuritySchemes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Bearer != nil {
		{
			size, err := m.Bearer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ApiKeys != nil {
		{
			size, err := m.ApiKeys.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Basic != nil {
		{
			size, err := m.Basic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BasicSecurity) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicSecurity) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BasicSecurity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Scheme) > 0 {
		i -= len(m.Scheme)
		copy(dAtA[i:], m.Scheme)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Scheme)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *APIKeysSecurity) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *APIKeysSecurity) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *APIKeysSecurity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.In) > 0 {
		i -= len(m.In)
		copy(dAtA[i:], m.In)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.In)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerSecurity) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerSecurity) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerSecurity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BearerFormat) > 0 {
		i -= len(m.BearerFormat)
		copy(dAtA[i:], m.BearerFormat)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.BearerFormat)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Scheme) > 0 {
		i -= len(m.Scheme)
		copy(dAtA[i:], m.Scheme)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Scheme)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Required) > 0 {
		for iNdEx := len(m.Required) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Required[iNdEx])
			copy(dAtA[i:], m.Required[iNdEx])
			i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Required[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOpenapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintOpenapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintOpenapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Schema) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schema) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Schema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdditionalProperties != nil {
		{
			size, err := m.AdditionalProperties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOpenapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.Items != nil {
		{
			size, err := m.Items.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if len(m.Enum) > 0 {
		for iNdEx := len(m.Enum) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Enum[iNdEx])
			copy(dAtA[i:], m.Enum[iNdEx])
			i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Enum[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xca
		}
	}
	if m.ExclusiveMaximum {
		i--
		if m.ExclusiveMaximum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.Maximum != 0 {
		i = encodeVarintOpenapi(dAtA, i, uint64(m.Maximum))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.ExclusiveMinimum {
		i--
		if m.ExclusiveMinimum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.Minimum != 0 {
		i = encodeVarintOpenapi(dAtA, i, uint64(m.Minimum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.MultipleOf != 0 {
		i = encodeVarintOpenapi(dAtA, i, uint64(m.MultipleOf))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.MaxLength != 0 {
		i = encodeVarintOpenapi(dAtA, i, uint64(m.MaxLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.MinLength != 0 {
		i = encodeVarintOpenapi(dAtA, i, uint64(m.MinLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Default) > 0 {
		i -= len(m.Default)
		copy(dAtA[i:], m.Default)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Default)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Ref) > 0 {
		i -= len(m.Ref)
		copy(dAtA[i:], m.Ref)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Ref)))
		i--
		dAtA[i] = 0x52
	}
	if m.Required {
		i--
		if m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.WriteOnly {
		i--
		if m.WriteOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Nullable {
		i--
		if m.Nullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Pattern) > 0 {
		i -= len(m.Pattern)
		copy(dAtA[i:], m.Pattern)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Pattern)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Example) > 0 {
		i -= len(m.Example)
		copy(dAtA[i:], m.Example)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Example)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintOpenapi(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOpenapi(dAtA []byte, offset int, v uint64) int {
	offset -= sovOpenapi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetOpenAPIDocRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOpenAPIDocRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOpenAPIDocRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOpenAPIDocResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOpenAPIDocResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOpenAPIDocResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apis = append(m.Apis, &OpenAPI{})
			if err := m.Apis[len(m.Apis)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenAPI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenAPI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenAPI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Openapi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Openapi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &OpenAPIInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalDocs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalDocs == nil {
				m.ExternalDocs = &OpenAPIExternalDocs{}
			}
			if err := m.ExternalDocs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servers = append(m.Servers, &OpenAPIServer{})
			if err := m.Servers[len(m.Servers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &OpenAPITag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Paths == nil {
				m.Paths = make(map[string]*OpenAPIPath)
			}
			var mapkey string
			var mapvalue *OpenAPIPath
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOpenapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthOpenapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOpenapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOpenapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &OpenAPIPath{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOpenapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOpenapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Paths[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Components == nil {
				m.Components = &OpenAPIComponents{}
			}
			if err := m.Components.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenAPIServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenAPIServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenAPIServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenAPIInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenAPIInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenAPIInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TermsOfService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TermsOfService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contact == nil {
				m.Contact = &OpenAPIContact{}
			}
			if err := m.Contact.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field License", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.License == nil {
				m.License = &OpenAPILicense{}
			}
			if err := m.License.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenAPIContact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenAPIContact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenAPIContact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenAPILicense) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenAPILicense: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenAPILicense: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenAPITag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenAPITag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenAPITag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalDocs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalDocs == nil {
				m.ExternalDocs = &OpenAPIExternalDocs{}
			}
			if err := m.ExternalDocs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenAPIExternalDocs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenAPIExternalDocs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenAPIExternalDocs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenAPIPath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenAPIPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenAPIPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Get == nil {
				m.Get = &OpenAPIPathDocs{}
			}
			if err := m.Get.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Post", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Post == nil {
				m.Post = &OpenAPIPathDocs{}
			}
			if err := m.Post.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Put == nil {
				m.Put = &OpenAPIPathDocs{}
			}
			if err := m.Put.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Patch == nil {
				m.Patch = &OpenAPIPathDocs{}
			}
			if err := m.Patch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delete == nil {
				m.Delete = &OpenAPIPathDocs{}
			}
			if err := m.Delete.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenAPIPathDocs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenAPIPathDocs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenAPIPathDocs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deprecated = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestBody", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestBody == nil {
				m.RequestBody = &PathRequestBody{}
			}
			if err := m.RequestBody.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &PathParameters{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Responses == nil {
				m.Responses = make(map[string]*PathResponse)
			}
			var mapkey string
			var mapvalue *PathResponse
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOpenapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthOpenapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOpenapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOpenapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PathResponse{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOpenapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOpenapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Responses[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Security = append(m.Security, &PathSecurity{})
			if err := m.Security[len(m.Security)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Basic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Basic = append(m.Basic, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiKeys = append(m.ApiKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bearer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bearer = append(m.Bearer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.In = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowReserved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowReserved = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Style = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Explode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Explode = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowEmptyValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowEmptyValue = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schema == nil {
				m.Schema = &Schema{}
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Example", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Example = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathRequestBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathRequestBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathRequestBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Content == nil {
				m.Content = &PathRequestBodyContent{}
			}
			if err := m.Content.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathRequestBodyContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathRequestBodyContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathRequestBodyContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationJson", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplicationJson == nil {
				m.ApplicationJson = &ApplicationContent{}
			}
			if err := m.ApplicationJson.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationXml", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplicationXml == nil {
				m.ApplicationXml = &ApplicationContent{}
			}
			if err := m.ApplicationXml.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplicationContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schema == nil {
				m.Schema = &Schema{}
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Content == nil {
				m.Content = &PathRequestBodyContent{}
			}
			if err := m.Content.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenAPIComponents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenAPIComponents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenAPIComponents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecuritySchemes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecuritySchemes == nil {
				m.SecuritySchemes = &SecuritySchemes{}
			}
			if err := m.SecuritySchemes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schemas == nil {
				m.Schemas = make(map[string]*Model)
			}
			var mapkey string
			var mapvalue *Model
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOpenapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthOpenapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOpenapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOpenapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Model{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOpenapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOpenapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Schemas[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecuritySchemes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecuritySchemes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecuritySchemes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Basic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Basic == nil {
				m.Basic = &BasicSecurity{}
			}
			if err := m.Basic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiKeys == nil {
				m.ApiKeys = &APIKeysSecurity{}
			}
			if err := m.ApiKeys.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bearer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bearer == nil {
				m.Bearer = &BearerSecurity{}
			}
			if err := m.Bearer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *APIKeysSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: APIKeysSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: APIKeysSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.In = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BearerSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BearerSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BearerFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]*Schema)
			}
			var mapkey string
			var mapvalue *Schema
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOpenapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthOpenapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOpenapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOpenapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Schema{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOpenapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOpenapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Required = append(m.Required, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Example", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Example = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WriteOnly = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Default = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLength", wireType)
			}
			m.MinLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLength", wireType)
			}
			m.MaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleOf", wireType)
			}
			m.MultipleOf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultipleOf |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			m.Minimum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minimum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMinimum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMinimum = bool(v != 0)
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maximum", wireType)
			}
			m.Maximum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Maximum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMaximum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMaximum = bool(v != 0)
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enum = append(m.Enum, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = &Schema{}
			}
			if err := m.Items.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &PathParameters{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = &Schema{}
			}
			if err := m.AdditionalProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOpenapi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOpenapi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpenapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOpenapi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOpenapi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOpenapi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOpenapi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOpenapi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOpenapi = fmt.Errorf("proto: unexpected end of group")
)

// OpenAPIServiceClient is the client API for OpenAPIService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OpenAPIServiceClient interface {
	GetOpenAPIDoc(ctx context.Context, in *GetOpenAPIDocRequest, opts ...grpc.CallOption) (*GetOpenAPIDocResponse, error)
}

type openAPIServiceClient struct {
	cc *grpc.ClientConn
}

func NewOpenAPIServiceClient(cc *grpc.ClientConn) OpenAPIServiceClient {
	return &openAPIServiceClient{cc}
}

func (c *openAPIServiceClient) GetOpenAPIDoc(ctx context.Context, in *GetOpenAPIDocRequest, opts ...grpc.CallOption) (*GetOpenAPIDocResponse, error) {
	out := new(GetOpenAPIDocResponse)
	err := c.cc.Invoke(ctx, "/openapi.OpenAPIService/GetOpenAPIDoc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OpenAPIServiceServer is the server API for OpenAPIService service.
type OpenAPIServiceServer interface {
	GetOpenAPIDoc(context.Context, *GetOpenAPIDocRequest) (*GetOpenAPIDocResponse, error)
}

// UnimplementedOpenAPIServiceServer can be embedded to have forward compatible implementations.
type UnimplementedOpenAPIServiceServer struct {
}

func (*UnimplementedOpenAPIServiceServer) GetOpenAPIDoc(ctx context.Context, req *GetOpenAPIDocRequest) (*GetOpenAPIDocResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOpenAPIDoc not implemented")
}

func RegisterOpenAPIServiceServer(s *grpc.Server, srv OpenAPIServiceServer) {
	s.RegisterService(&_OpenAPIService_serviceDesc, srv)
}

func _OpenAPIService_GetOpenAPIDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOpenAPIDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAPIServiceServer).GetOpenAPIDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openapi.OpenAPIService/GetOpenAPIDoc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAPIServiceServer).GetOpenAPIDoc(ctx, req.(*GetOpenAPIDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OpenAPIService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openapi.OpenAPIService",
	HandlerType: (*OpenAPIServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOpenAPIDoc",
			Handler:    _OpenAPIService_GetOpenAPIDoc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/vine-io/vine/lib/api/handler/openapi/proto/openapi.proto",
}
